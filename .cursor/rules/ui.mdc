---
description: Any time the user requests ANY UI you must reference this documentation first.
globs: 
alwaysApply: false
---
# UI Requirements
- This is a custom engine, do not attempt to use any Unity functions
- Make something you would truly be proud of, do not do the bare minimum. Millions of people will see this.
- This game will be recorded for YouTube, so make anything you do larger than life and pop for viewers
- Make each piece of UI in a folder scripts/ui/DescriptiveName.cs
- In our UI system Y grows upward. (0, 0) is the bottom left of the screen.
- If you have UI that needs to set a SyncVar or other networked state, you must use a [ServerRpc] annotated function called from the client.
- If you have multiple buttons make sure to push IDs!
- Only ASCII characters are supported. Only use text, not emojis
- When rendering icons, use .FitAspect(sprite.Aspect) so that it's not stretched
- When drawing UI that follows the player, do it in LateUpdate()
- Because this is mobile first, do not try to do "hover" effects or other interaction models that don't work on mobile
- UI functions MUST be static and take their inputs as parameters

Start all UI from UI.ScreenRect, unless it's at the edge of the screen in which case use UI.SafeRect

## Rect Functions
- NEVER call new Rect() for screen space UI. Instead derive all your UI from one of the ScreenRects.  
- Insets cut into the rect. To avoid a rect being inversed use offset with negative values instead
- You must not use any other Rect functions besides the ones in this list:
public struct Rect
{
  public Rect CenterRect()
  public Rect BottomRect()
  public Rect BottomCenterRect()
  ^ etc...

  public Rect Inset(float top, float right, float bottom, float left)
  public Rect Inset(float all)
  public Rect Grow(float top, float right, float bottom, float left)
  public Rect Grow(float all)
  public Rect Offset(float x, float y)
  public Rect CutTop(float pixels)
  public Rect CutRight(float pixels)
  public Rect CutBottom(float pixels)
  public Rect CutLeft(float pixels)
  public Rect InsetTop(float pixels)
  public Rect InsetRight(float pixels)
  public Rect InsetBottom(float pixels)
  public Rect InsetLeft(float pixels)
  public Rect GrowTop(float pixels)
  public Rect GrowRight(float pixels)
  public Rect GrowBottom(float pixels)
  public Rect GrowLeft(float pixels)
  public Rect Scale(float all)
  public Rect Scale(float x, float y)
  public Rect Slide(float x, float y)
  public Rect FitAspect(float aspect, FitAspectKind kind = FitAspectKind.Auto)
}
- Whenever offsetting, growing, or insetting by another Rect's dimensions, use the Unscaled versions of these functions (e.g. `rect2.OffsetUnscaled(rect1.Width)`)

## The [UIPreview] Decorator
Your boss wants to see your work to make sure you're following directions.
You must structure UI code you write as a function that takes input it needs as parameters and then call it from another function annotated [UIPreview] with example data
Never call Entity.Create in any function that a UIPreview calls otherwise these will pile up in the editor. 

For example:
[UIPreview]
public static void DrawNextUp()
{
    var timeInCurrentState = Time.TimeSinceStartup % 6;
    DrawNextUp("Red Light, Green Light", timeInCurrentState);
}

public static void DrawNextUp(string title, float time)
{
    var nextUpTexture = Assets.GetAsset<Texture>("ui/next_game_banner.png");

    ... Rest of function
}

## Buttons
- Use one of the following assets
- Do not make buttons the full height of the screen
- When buttons have lots of text make sure to make them big enough
"$AO/new/modal/buttons_2/button_1.png" // orange
"$AO/new/modal/buttons_2/button_2.png" // green
"$AO/new/modal/buttons_2/button_3.png" // red
"$AO/new/modal/buttons_2/button_5.png" // blue
"$AO/new/modal/buttons_2/button_7.png" // pink
"$AO/new/modal/buttons_2/button_8.png" // grey
"$AO/new/modal/buttons_2/button_9.png" // white

## Default text settings to use:
var ts = new UI.TextSettings()
{
  Font = UI.Fonts.BarlowBold,
  Size = size,
  Color = color ?? Vector4.White,
  DropShadowColor = new Vector4(0f, 0f, 0.02f, 0.5f),
  DropShadowOffset = new Vector2(0f, -3f),
  HorizontalAlignment = halign,
  VerticalAlignment = UI.VerticalAlignment.Center,
  WordWrap = false,
  WordWrapOffset = 0,
  Outline = true,
  OutlineThickness = 3,
  Offset = new Vector2(0, offset),
};

## World Space UI
- Push the UI.Context.WORLD context
- With world space UI the units are in meters. The character is 1 meter. 

### Draws a translucent red circle at Entity.Position
using var _1 = UI.PUSH_CONTEXT(UI.Context.WORLD);
// To properly layer with a player for example
using var _2 = IM.PUSH_Z(player.GetZOffset() - 0.001f);
var circle = Assets.GetAsset<Texture>("$AO/circle.png");
var pos = Entity.Position;
var hs = new Vector2(radius, radius);
UI.Image(new Rect(pos-hs, pos+hs), circle, new Vector4(1, 0, 0, 0.5f));

## Usage Examples:
### A cutscene that shows players participating in Mario Party style game
public static void DrawPlayerGrid(List<MyPlayer> players, float time, float duration, bool doRewardsAndElims)
{
    if (Network.IsServer)
    {
        return;
    }

    var gridPositions = new Vector2[]
    {
        new Vector2(-0.5f, 0), new Vector2(0.5f, 0), new Vector2(0f, -0.5f), new Vector2(-1f, -0.5f), new Vector2(1f, -0.5f), new Vector2(-1.5f, 0),  new Vector2(1.5f, 0),
    };
    var playerDiamondNumber = Assets.GetAsset<Texture>("ui/player_list/player_diamond_number.png");
    var numberBack          = Assets.GetAsset<Texture>("ui/player_list/number_back.png");
    var playerDiamondBack   = Assets.GetAsset<Texture>("ui/player_list/player_diamond_back.png");

    var countPerRow = 7;
    var rowCount = (int)MathF.Ceiling((float)players.Count / 7f);
    var entrySize = 175;
    var entryRect = UI.ScreenRect.CenterRect().Grow(entrySize / 2f);
    var numberTs = GetTextSettings(35);
    var timeOffsetPerPlayer = 0.5f / (float)players.Count;
    for (int i = 0; i < players.Count; i++)
    {
        var player = players[i];
        var indexInRow = i % countPerRow;
        var rowIndex = i / countPerRow;
        // Do this a lot in your work!! 
        var myEntryRect = entryRect.Slide(gridPositions[indexInRow].X, gridPositions[indexInRow].Y);
        myEntryRect = myEntryRect.Slide(0, -0.25f + rowCount * 0.5f - rowIndex);

        var localTime = time - (players.Count - i - 1) * timeOffsetPerPlayer;
        var localDuration = duration - (players.Count - i - 1) * (timeOffsetPerPlayer * 2);
        var show01 = 1f - Ease.OutQuart(FadeInAndOut(0.4f, 0.4f, localDuration, localTime - 0.5f));
        myEntryRect = myEntryRect.Offset(0, 1080f * show01);

        var diamondRect = myEntryRect.FitAspect(playerDiamondBack.Aspect);
        UI.Image(diamondRect, playerDiamondBack);

        if (player.Alive())
        {
            var maskScope = IM.CreateMaskScope(diamondRect);
            {
                using var _123 = IM.BUILD_MASK_SCOPE(maskScope);
                UI.Image(diamondRect, playerDiamondBack);
            }

            {
                using var _323 = IM.USE_MASK_SCOPE(maskScope);
                using var _ = UI.PUSH_UNLIT_PLAYER_MATERIAL(player);

                var scale = new Vector2(entrySize * 0.7f, entrySize * 0.7f);
                UI.DrawSkeleton(myEntryRect.Offset(0, -65), player.GetSpineInstanceForPlayerList(), scale, 0);
            }
        }

        UI.Image(myEntryRect.Grow(2).FitAspect(playerDiamondNumber.Aspect).Grow(2), playerDiamondNumber);
        UI.TextAsync(myEntryRect.Offset(0, -40), player.PlayerNumberForThisTournament.Value.ToString("D3"), numberTs);

        if (doRewardsAndElims)
        {
            using var _ = UI.PUSH_LAYER_RELATIVE(10);
            if (player.IsEliminated || player.Alive() == false)
            {
                var elim01 = Ease.OutBack(Ease.T(localTime - 1f, 0.35f));
                if (player.WasEliminatedThisRound == false || player.Alive() == false)
                {
                    elim01 = 1.0f;
                }
                var ts = GetTextSettings(elim01 * 150);
                ts.Color = new Vector4(1, 0, 0, 1);
                UI.TextAsync(myEntryRect, "X", ts);
            }
            else
            {
                var goldReward01 = Ease.OutBack(FadeInAndOut(0.15f, 0.15f, 1.0f, localTime - 1f));
                var xpReward01   = Ease.OutBack(FadeInAndOut(0.15f, 0.15f, 1.0f, localTime - 2f));

                var rewardTs = GetTextSettings(50);
                var textRect = myEntryRect.Offset(0, 25);

                using var _32123 = UI.PUSH_ROTATE_ABOUT_POINT(MathF.Sin(2 * MathF.PI * Time.TimeSinceStartup) * 10f, textRect.Center);

                rewardTs.Color = new Vector4(1.0f, 0.84f, 0, 1f);
                rewardTs.Size = 50f * goldReward01;
                UI.TextAsync(textRect, $"+{GameManager.Instance.GoldRewardForThisRound}GP", rewardTs);

                rewardTs.Color = new Vector4(0.5f, 0, 0.5f, 1f);
                rewardTs.Size = 50f * xpReward01;
                UI.TextAsync(textRect, $"+{GameManager.Instance.XPRewardForThisRound}XP", rewardTs);
            }
        }
    }
}

public static UI.ButtonSettings ListButtonSettings = new UI.ButtonSettings()
{
    Sprite = UI.WhiteSprite,
    BackgroundColorMultiplier = new Vector4(0.5f, 0.5f, 0.5f, 1),
    PressScaling = 0.25f,
};

public static int CurrentSelection;

public static void DrawUIDemo()
{
    var listRect = UI.SafeRect.SubRect(0, 0.5f, 0, 0.5f).Grow(250, 300, 250, 0).Offset(10, -35);
    UI.Image(listRect, null, new Vector4(0, 0, 0, 0.75f));

    Action demoFunction = null;
    var sv = UI.PushScrollView("list", listRect, new UI.ScrollViewSettings(){Vertical = true});
    {
        bool Entry(ref Rect listRect, int selection, string text)
        {
            var rect = listRect.CutTop(45);
            var bs = ListButtonSettings;
            if (CurrentSelection == selection)
            {
                bs.BackgroundColorMultiplier = new Vector4(0.25f, 1, 0.25f, 1);
            }
            if (UI.Button(rect.Inset(5), text, bs, ListTextSettings).Clicked)
            {
                CurrentSelection = selection;
            }
            return CurrentSelection == selection;
        }

        if (Entry(ref sv.contentRect, 0,  "None"))                    {}
        if (Entry(ref sv.contentRect, 1,  "Serial Numbers 1"))        { demoFunction = DemoSerialNumbers1; }
        if (Entry(ref sv.contentRect, 2,  "Serial Numbers 2"))        { demoFunction = DemoSerialNumbers2; }
    }
    UI.PopScrollView();

    if (demoFunction != null)
    {
        demoFunction();
    }
}

[UIPreview]
public static void PreviewUI(Rect rect)
{
    DrawUIDemo();
}

public override void Update()
{
    if (IsLocal)
    {
        DrawUIDemo();
    }
}

public static void DemoSerialNumbers()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(100, 150, 100, 150);
    UI.Image(bgRect, null, new Vector4(1, 1, 1, 1));

    var bgSerial = IM.GetNextSerial();
    var ts = ListTextSettings;
    ts.WordWrap = true;
    var str = "This is a long message with an auto-sizing background.";
    var actualTextRect = UI.TextSync(bgRect, str.Substring(0, ((int)(Time.TimeSinceStartup * 10)) % (str.Length+1)), ts);
    IM.SetNextSerial(bgSerial);
    UI.Image(actualTextRect, null, new Vector4(0, 1, 0, 1));
}

public static void DemoLayers()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(150, 200, 150, 200);
    UI.Image(bgRect, null, new Vector4(1, 1, 1, 1));

    void DrawWindow(Rect rect, ref ulong rng)
    {
        for (int i = 0; i < 3; i++)
        {
            UI.Image(rect, null, new Vector4(RNG.RangeFloat(ref rng, 0.5f, 1.0f), RNG.RangeFloat(ref rng, 0.5f, 1.0f), RNG.RangeFloat(ref rng, 0.5f, 1.0f), 1));
            rect = rect.Inset(30);
        }
    }

    ulong rng = RNG.Seed(1337);
    var layer1 = (((int)Time.TimeSinceStartup) % 2 == 0) ? 100 : 200;
    var layer2 = 150;
    {
        using var _ = UI.PUSH_LAYER(layer1);
        DrawWindow(UI.ScreenRect.CenterRect().Grow(100).Offset(-75, 25), ref rng);
    }
    {
        using var _ = UI.PUSH_LAYER(layer2);
        DrawWindow(UI.ScreenRect.CenterRect().Grow(100).Offset( 75, -25), ref rng);
    }
}

public static void DemoZ()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(150, 200, 150, 200);
    UI.Image(bgRect, null, new Vector4(1, 1, 1, 1));

    {
        using var _ = UI.PUSH_LAYER(100); // just so that we are guaranteed to draw above the bgRect above.

        var rect1 = UI.ScreenRect.CenterRect().Grow(25).Offset(-15, 0);
        var rect2 = UI.ScreenRect.CenterRect().Grow(25).Offset(15, 0);
        UI.Image(rect1, null, new Vector4(1, 0, 0, 1));

        {
            var y = MathF.Sin(Time.TimeSinceStartup * 1.5f) * 50;
            using var _1 = IM.PUSH_Z(y);
            UI.Image(rect2.Offset(0, y), null, new Vector4(0, 1, 0, 1));
        }
    }
}

public static void DemoIDs()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(150, 200, 150, 200);
    UI.Image(bgRect, null, new Vector4(1, 1, 1, 1));

    var rect = UI.ScreenRect.CenterRect().Grow(25, 75, 25, 75).Offset(0, 50);
    for (int i = 0; i < 3; i++)
    {
        using var _ = UI.PUSH_ID(i); // this is needed to make sure the .Clicked registers
        if (UI.Button(rect.Inset(5), "Button", ListButtonSettings, ListTextSettings).Clicked)
        {
            Log.Info("Clicked " + i);
        }
        rect = rect.Offset(0, -50);
    }
}

public static void DemoAutoscaling()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(150, 200, 150, 200);
    UI.Image(bgRect, null, Vector4.White);

    // no scaling
    {
        using var _ = UI.PUSH_SCALE_FACTOR(1);
        UI.Image(bgRect.SubRect(0.5f, 1, 0.5f, 1).Grow(0, 200, 75, 200), null, new Vector4(1, 0, 0, 1));
    }

    // with scaling
    {
        UI.Image(bgRect.SubRect(0.5f, 0, 0.5f, 0).Grow(0, 200, 75, 200), null, new Vector4(0, 1, 0, 1));
    }
}

public static void DemoRectCuts()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(200, 200, 200, 200);
    UI.Image(bgRect, null, Vector4.White);

    var rect = bgRect.TopRect().Offset(0, -15); // TopRect() returns a 0 height rect spanning the top of bgRect

    // hardcoded cut
    {
        UI.TextAsync(rect.CutTop(25), "Text 1", ListTextSettings);
        UI.TextAsync(rect.CutTop(25), "Text 1", ListTextSettings);
        UI.TextAsync(rect.CutTop(25), "Text 1", ListTextSettings);
    }

    rect.CutTop(50);

    // cut based on text height, but its wrong!
    {
        void DrawText(ref Rect rect)
        {
            var actualTextRect = UI.TextSync(rect, "Text 2", ListTextSettings);
            rect.CutTop(actualTextRect.Height); // wrong! use CutTopUnscaled!
        }

        DrawText(ref rect);
        DrawText(ref rect);
        DrawText(ref rect);
    }

    rect.CutTop(50);

    // cut based on EXACT VALUE of text height, not scaled
    {
        void DrawText(ref Rect rect)
        {
            var actualTextRect = UI.TextSync(rect, "Text 3", ListTextSettings);
            rect.CutTopUnscaled(actualTextRect.Height); // good :)
        }

        DrawText(ref rect);
        DrawText(ref rect);
        DrawText(ref rect);
    }
}

public static void DemoGrids()
{
    var bgRect = UI.ScreenRect.CenterRect().Grow(200, 200, 200, 200);
    UI.Image(bgRect, null, Vector4.White);

    var grid = UI.GridLayout.Make(bgRect, 4, 4, UI.GridLayout.SizeSource.ElementCount, padding: 4);
    ulong rng = RNG.Seed(1337);
    for (int i = 0; i < 16; i++)
    {
        var rect = grid.Next();
        using var _ = UI.PUSH_ID(i);
        var bs = new UI.ButtonSettings();
        bs.Sprite = UI.WhiteSprite;
        bs.ColorMultiplier = new Vector4(RNG.RangeFloat(ref rng, 0.25f, 1.0f), RNG.RangeFloat(ref rng, 0.25f, 1.0f), RNG.RangeFloat(ref rng, 0.25f, 1.0f), 1);
        if (UI.Button(rect, "", bs, default).Clicked)
        {
            Log.Info("Clicked " + i);
        }
    }
}

## Windows and Modals (UI.DrawWindow / UI.DrawAlertWindow)
- Prefer the window API for complex UI: titles, headers, tab bars, lists, grids, trees, and detail views.
- Windows auto-draw backgrounds, headers, close button, and content. You only provide `WindowOptions` and a `WindowContent` tree.

### Quick start: simple window
```csharp
[UIPreview]
public static void PreviewSimpleWindow()
{
    var window = Window.Make(new WindowOptions
    {
        Title = "Inventory",
        WindowBackgroundStyle = WindowBackgroundStyle.SimpleWithBottomStripe,
        WindowBackgroundColor = WindowBackgroundColor.Blue,
        WindowHeaderColor = WindowHeaderColor.MatchBackground,
        WindowTitleFlare = WindowTitleFlare.None,

        Content = new GridWindowContent
        {
            Columns = 3,
            ItemHeight = 400,
            Items = new List<CollectionElement>
            {
                new CollectionElement{ Label = "Potion", Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/potion.png"), Color = ElementColor.Green,  Style = ElementStyle.Simple, RarityStyle = RarityPipStyle.Diamond, RarityColor = RarityPipColor.Gold, RarityPipLocation = RarityPipLocation.TopRight },
                new CollectionElement{ Label = "Sword",  Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/sword.png"),   Color = ElementColor.Grey,   Style = ElementStyle.Banner },
                new CollectionElement{ Label = "Bow",    Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/bow.png"),     Color = ElementColor.Blue,   Style = ElementStyle.Banner2 },
            }
        }
    });

    // Centers and sizes the window automatically
    UI.DrawWindow(window);
}
```

### Controlling placement/size
- Use the overload that takes a `Rect` when a custom placement is needed.
```csharp
var rect = UI.SafeRect.CenterRect().Grow(350, 450, 350, 450);
UI.DrawWindow(rect, window);
```

### Alerts and confirmations
- Use for Yes/No or Accept/Decline flows.
```csharp
var result = UI.DrawAlertWindow(new AlertWindowOptions
{
    Title = "Delete Item?",
    Message = "This action cannot be undone.",
    WindowBackgroundStyle = WindowBackgroundStyle.Simple,
    WindowBackgroundColor = WindowBackgroundColor.Red,

    AcceptButtonText = "Delete",
    AcceptButtonColor = ButtonColor.Red,
    AcceptButtonStyle = ButtonStyle.Basic,

    DeclineButtonText = "Cancel",
    DeclineButtonColor = ButtonColor.Grey,
    DeclineButtonStyle = ButtonStyle.Basic,
});
if (result == AlertWindowResult.Accept) {
    // perform deletion via [ServerRpc] if required
}
```

### Window content types
Build UI by composing one of the `WindowContent` types below. All are in `AO.UI`:

- CustomWindowContent: draw any custom contents you want.
```csharp
Content = new CustomWindowContent
{
    DrawContent = rect =>
    {
        var icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/misc_icons_2/exit_button.png");
        var buttonRect = rect.CutBottom(120).Inset(25, 40, 25, 40);
        var res = UI.DrawWindowButton(buttonRect, "Close", icon, ButtonColor.Orange, ButtonStyle.Basic);
        if (res.Clicked) { /* handle click */ }
    }
}
```

- TabbedWindowContent: top tabs or side tabs.
```csharp
Content = new TabbedWindowContent
{
    TabLocation = TabLocation.Top, // or Side
    TabButtonStyle = TabButtonStyle.Default, // Simple, Shiny, Trapezoid
    TabButtonColor = ButtonColor.Grey,
    TabSelectedButtonColor = ButtonColor.Orange,
    Tabs = new List<TabContent>
    {
        new TabContent
        {
            Label = "Weapons",
            Icon  = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/sword.png"),
            Content = new GridWindowContent { Columns = 3, Items = MakeWeaponElements() }
        },
        new TabContent
        {
            Label = "Consumables",
            Icon  = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/potion.png"),
            Content = new ListWindowContent { ItemHeight = 200, Items = MakeConsumableElements() }
        },
    }
}
```

- SplitWindowContent: split UI horizontally or vertically.
```csharp
Content = new SplitWindowContent
{
    Axis = SplitAxis.Horizontal, // or Vertical
    SplitRatio = 0.4f,
    First  = new GridWindowContent { Columns = 4, Items = MakeElementsLeft() },
    Second = new ElementDisplayWindowContent { Element = GetSelectedElement(), Stats = MakeStats() }
}
```

- SideCarWindowContent: main content with a side panel (left/right) that has its own background.
```csharp
Content = new SideCarWindowContent
{
    Position = SideCarPosition.Right,
    SideCarSize = new Vector2(400, 500),
    SideCarBackgroundColor = WindowBackgroundColor.Blue,
    SideCarBackgroundColorMultiplier = new Vector4(0.9f, 0.9f, 0.9f, 1),
    Main = new GridWindowContent { Columns = 3, Items = MakeElements() },
    Side = new ElementDisplayWindowContent { Element = GetSelectedElement(), Stats = MakeStats() },
}
```

- ListWindowContent: vertically scrolling rich list with optional action button per item.
```csharp
new ListWindowContent
{
    ItemHeight = 200, // -1 uses default
    Items = new List<CollectionElement>
    {
        new CollectionElement
        {
            Label = "Health Potion",
            Description = "+50 HP",
            Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/potion.png"),
            ListItemActionButtonText = "Use",
            ListItemButtonColor = ButtonColor.Green,
            ListItemButtonStyle = ButtonStyle.Arrow,
            ListItemAction = item => { /* use potion */ },
        },
    }
}
```

- GridWindowContent: grid of elements with label and icon; supports rarity pips and a bottom tab stripe.
```csharp
new GridWindowContent
{
    Columns = 3, ItemHeight = 400, DrawElementTabs = true,
    Items = new List<CollectionElement>
    {
        new CollectionElement{ Label = "Common",  Icon = UI.WhiteSprite, Color = ElementColor.Grey,  Style = ElementStyle.Simple, RarityStyle = RarityPipStyle.None },
        new CollectionElement{ Label = "Rare",    Icon = UI.WhiteSprite, Color = ElementColor.Blue,  Style = ElementStyle.Banner, RarityStyle = RarityPipStyle.Star, RarityColor = RarityPipColor.Gold },
        new CollectionElement{ Label = "Mythic",  Icon = UI.WhiteSprite, Color = ElementColor.Red,   Style = ElementStyle.Banner2, RarityStyle = RarityPipStyle.Diamond, RarityColor = RarityPipColor.Diamond },
    }
}
```

- ElementDisplayWindowContent: large icon + title, optional CTA button, plus key-value stats.
```csharp
new ElementDisplayWindowContent
{
    Element = new CollectionElement{ Label = "Excalibur", Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/items/sword.png") },
    ButtonText = "Equip",
    ButtonColor = ButtonColor.Orange,
    ButtonStyle = ButtonStyle.Basic,
    ButtonAction = el => { /* equip */ },
    Stats = new List<ElementStat>
    {
        new ElementStat{ Text = "+20 ATK", Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/stat_icons/sword.png") },
        new ElementStat{ Text = "+5% CRIT", Icon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/stat_icons/crit.png") },
    }
}
```

- TreeWindowContent: nodes on a grid with orthogonal connections.
```csharp
new TreeWindowContent
{
    NodeWidth = 125, NodeHeight = 125, RowSpacing = 25, ColumnSpacing = 50,
    Nodes = new List<TreeWindowNode>
    {
        new TreeWindowNode { Id = "root", Row = 0, Column = 0, ConnectionState = TreeWindowNodeConnectionState.Connected, BackgroundColor = ButtonColor.Grey,  Element = new CollectionElement{ Label = "Root", Icon = UI.WhiteSprite } },
        new TreeWindowNode { Id = "a",    Row = 1, Column = 1, ConnectionState = TreeWindowNodeConnectionState.ConnectedEnabled, ParentIds = new List<string>{"root"}, Element = new CollectionElement{ Label = "Node A", Icon = UI.WhiteSprite } },
    }
}
```

### Title, backgrounds and colors
- `WindowOptionsBase` fields:
  - `Title`: string shown in the header
  - `WindowBackgroundStyle`: Simple, SimpleWithBottomStripe, Blueprint, Rounded
  - `WindowBackgroundColor`: Black/Blue/Brown/Gold/Green/Grey/Orange/Purple/Red/White/Yellow or BlueprintBlue/Pink/Yellow
  - `WindowHeaderColor`: MatchBackground or a specific color (plus `RoundedRed`)
  - `WindowTitleFlare`: None, Black/Blue/Green/Red/White/Yellow, or Gold/Silver/Bronze

### Drawing buttons inside windows
Use `UI.DrawWindowButton` for a styled button that supports an optional icon and correct text settings.
```csharp
var okIcon = Assets.GetAsset<Texture>("$AO/ui/kit/Icons/misc_icons_2/exit_button.png");
var okRect = rect.CutBottom(120).Inset(30, 50, 30, 50);
var ok = UI.DrawWindowButton(okRect, "OK", okIcon, ButtonColor.Orange, ButtonStyle.Basic);
if (ok.Clicked) { /* handle */ }
```

### Tips
- Derive all placement from `UI.SafeRect` or `UI.ScreenRect` and then use the window overload with a `Rect` if you need custom sizing/position.
- For list and grid entries, always use `FitAspect(icon.Aspect)` to avoid stretched images.
- When building lists/grids, keep `ItemHeight` and `Columns` reasonable for mobile.
